# Default Agent Mappings

## Default Subagent Delegation Policy

**IMPORTANT**: When a user prompt matches a subagent's specialization, **ALWAYS delegate to the appropriate subagent** rather than handling the task directly. This ensures:
- Consistent behavior through specialized skills
- Proper tool isolation and access control
- Maintainable, modular task handling
- Best-practice enforcement by domain experts

### Delegation Decision Tree

1. **Does the task match a routing pattern?** → Delegate to matching subagent
2. **Is the task within a subagent's domain?** → Delegate to that subagent
3. **Multiple subagents applicable?** → Delegate to the most specific one
4. **No subagent match?** → Analyze for skill match
5. **Skill found?** → Load and execute skill workflow
6. **Multiple independent tasks?** → Ask user confirmation, then execute in parallel
7. **No skill match?** → Handle directly with available tools

### When to Delegate (Examples)

| User Prompt | Delegate To | Reason |
|-------------|-------------|--------|
| "lint my code" | `linting-subagent` | Matches `lint*` pattern |
| "write tests for auth" | `testing-subagent` | Matches `test*` pattern |
| "create PR for this branch" | `git-workflow-subagent` | Matches `pr*` pattern |
| "add docstrings to utils" | `documentation-subagent` | Matches `doc*` pattern |
| "deploy to EKS" | `opentofu-explorer-subagent` | Matches `eks*` pattern |
| "analyze this screenshot" | `image-analyzer` | Matches `screenshot*` pattern |
| "create architecture diagram" | `diagram-creator` | Matches `diagram*` pattern |
| "find all API routes" | `explore` | Matches `find*` pattern |

### Skill Matching Fallback

When no subagent matches the task, analyze the task to find suitable skills:

1. **Extract keywords** from user prompt
2. **Match against skill names** and descriptions
3. **Load matching skill** using `skill` tool
4. **Execute skill workflow** for task completion

**Skill Matching Examples**:

| User Prompt | Skill Match | Reason |
|-------------|-------------|--------|
| "create a Next.js app" | `nextjs-standard-setup` | Matches `nextjs*` and `setup*` |
| "generate Python tests" | `python-pytest-creator` | Matches `python*` and `test*` |
| "lint TypeScript code" | `javascript-eslint-linter` | Matches `lint*` and TypeScript |
| "add TSDoc to functions" | `nextjs-tsdoc-documentor` | Matches `doc*` and TypeScript |
| "provision ECR repository" | `opentofu-ecr-provision` | Matches `ecr*` and `provision*` |

---

## Parallel Task Execution

When a task list is known (from user prompt or PLAN*.md file), analyze dependencies to maximize parallel execution:

**Decision Process**:
1. **Parse task list** - Extract all tasks from prompt or PLAN*.md file when explicitly referenced
2. **Identify dependencies** - Determine which tasks depend on others
3. **Group independent tasks** - Tasks with no dependencies can run in parallel
4. **Ask user confirmation** - Present parallel execution plan and get approval
5. **Launch parallel subagents** - Execute independent tasks simultaneously (max 3-5)
6. **Sequential execution** - Tasks with dependencies wait for prerequisites

**Dependency Detection Rules**:

| Dependency Type | Example | Must Wait For |
|-----------------|---------|---------------|
| File creation | "Edit `auth.ts`" | "Create `auth.ts`" |
| Test execution | "Run tests" | "Write tests", "Implement feature" |
| Documentation | "Update README" | "Implement feature" |
| Build/deploy | "Deploy to EKS" | "Run tests", "Build image" |
| Lint/format | "Lint code" | "Write code" |

**Parallel Execution Examples**:

| Tasks | Parallel? | Reason |
|-------|-----------|--------|
| `lint frontend/`, `lint backend/` | ✅ Yes | Independent directories |
| `write tests for auth`, `write tests for user` | ✅ Yes | Independent modules |
| `create PLAN.md`, `create GitHub issue` | ✅ Yes | Independent operations |
| `implement feature`, `test feature` | ❌ No | Test depends on implementation |
| `create EKS cluster`, `deploy to EKS` | ❌ No | Deploy depends on cluster |

**Execution Pattern**:
```
Phase 1 (Parallel - after user confirmation):
├── subagent A: lint frontend/
├── subagent B: lint backend/
└── subagent C: write tests for auth/

Phase 2 (After Phase 1 complete):
├── subagent A: implement feature (depends on tests written)
└── subagent B: update documentation (can run parallel to A)

Phase 3 (After Phase 2 complete):
└── subagent A: run all tests (depends on implementation)
```

**Configuration**:
- **Mode**: Manual (user confirmation required before parallel execution)
- **Max Subagents**: 3-5 (avoid resource exhaustion)
- **Task Sources**: User prompt OR PLAN*.md files when explicitly referenced

---

### Task Type → Subagent

| Task Type | Subagent | Description |
|-----------|----------|-------------|
| Code linting | `linting-subagent` | Enforce code quality standards |
| Testing | `testing-subagent` | Generate and run tests |
| Git operations | `git-workflow-subagent` | Branch, commit, PR, issue management |
| Documentation | `documentation-subagent` | Generate docstrings, update docs |
| Infrastructure | `opentofu-explorer-subagent` | Terraform/ToFu infrastructure |
| Workflows | `workflow-subagent` | PR workflows, automation |
| Image analysis | `image-analyzer` | Analyze screenshots, UI to code |
| Diagram creation | `diagram-creator` | Create architecture diagrams |
| Codebase exploration | `explore` | Search and understand codebase |

---

## Subagent Routing Rules

### Automatic Routing Patterns

#### Code Quality Tasks
Pattern → Subagent:
- `lint*`, `fix*style*`, `format*`, `quality*`, `clean*` → `linting-subagent`
- Examples: "lint the code", "fix style issues", "format python files"

#### Testing Tasks
Pattern → Subagent:
- `test*`, `spec*`, `coverage*`, `assert*`, `unit*`, `integration*` → `testing-subagent`
- Examples: "write tests", "check coverage", "test the function"

#### Git/JIRA Tasks
Pattern → Subagent:
- `branch*`, `commit*`, `pr*`, `issue*`, `merge*`, `checkout*` → `git-workflow-subagent`
- Examples: "create branch", "make commit", "create PR", "update issue"

#### Documentation Tasks
Pattern → Subagent:
- `doc*`, `readme*`, `comment*`, `example*`, `tutorial*`, `guide*` → `documentation-subagent`
- Examples: "update documentation", "write docstrings", "update README"

#### Infrastructure Tasks
Pattern → Subagent:
- `infra*`, `terraform*`, `tofu*`, `k8s*`, `aws*`, `kubernetes*`, `cloud*`, `ec2*`, `s3*`, `eks*` → `opentofu-explorer-subagent`
- Examples: "deploy to AWS", "setup Kubernetes", "Terraform configuration"

#### Workflow Tasks
Pattern → Subagent:
- `workflow*`, `automation*`, `pipeline*`, `ci*`, `cd*` → `workflow-subagent`
- Examples: "setup CI/CD", "automate workflow", "create pipeline"

### Specialized Routing

#### Image Analysis
- `screenshot*`, `image*`, `ui*design*`, `mockup*` → `image-analyzer`
- Examples: "analyze screenshot", "convert UI to code"

#### Diagram Creation
- `diagram*`, `architecture*`, `flowchart*`, `uml*`, `sequence*` → `diagram-creator`
- Examples: "create architecture diagram", "draw flowchart"

#### Codebase Exploration
- `find*`, `search*`, `explore*`, `locate*` → `explore`
- Examples: "find all files", "search for function", "explore codebase"

### Routing Priority

1. **Exact pattern match** - highest priority
2. **Keyword match** - medium priority
3. **Task type inference** - lower priority
4. **Skill match** - find suitable skill based on task keywords
5. **Handle directly** - use available tools if no skill match

---

## Subagent Tool Restrictions

### Tool Access Levels

#### Default Agent (Full Access)
The default agent has unrestricted access to all standard tools:
- `read`, `write`, `edit`, `glob`, `grep`
- `bash`, `task`, `todowrite`, `todoread`, `question`
- MCP servers as configured
- All skills via `permission.skill.*: allow`

#### Subagents (Limited Access)
Subagents have restricted access to tools based on their specialized role:

| Subagent | Allowed Tools | MCP Access | Allowed Skills | Purpose |
|----------|--------------|------------|----------------|---------|
| `image-analyzer` | `read`, `glob` | `zai-mcp-server` | None | Analyze images only, no file modifications |
| `diagram-creator` | `read`, `glob`, `grep` | `drawio` | None | Create diagrams, analyze code for visualization |
| `linting-subagent` | `read`, `write`, `edit`, `glob`, `grep` | None | Linting skills only | Fix linting issues, apply auto-fixes |
| `testing-subagent` | `read`, `write`, `edit`, `glob`, `grep` | None | Testing skills only | Generate test files, no execution |
| `git-workflow-subagent` | `read`, `write`, `edit`, `glob`, `grep` | `atlassian` | Git/JIRA skills only | Manage branches, PRs, issues (git via bash delegated) |
| `documentation-subagent` | `read`, `write`, `edit`, `glob`, `grep` | None | Documentation skills only | Generate docstrings, update docs |
| `opentofu-explorer-subagent` | `read`, `write`, `edit`, `glob`, `grep` | None | OpenTofu skills only | Manage Terraform configs (tofu via bash delegated) |
| `workflow-subagent` | `read`, `write`, `edit`, `glob`, `grep` | `atlassian` | Workflow/Git/JIRA skills only | Coordinate workflows (bash commands delegated) |

### Forbidden Tools for Subagents

Subagents are explicitly restricted from:
- `bash` - Must delegate system commands to parent agents
- `task` - Cannot launch other agents (prevents uncontrolled delegation)
- `todowrite`/`todoread` - Cannot manage task lists
- `question` - Cannot ask user for input directly
- `skill` loading beyond their specialization (via permission restrictions)
- MCP servers not listed in their configuration

### Subagent Tool Usage Principles

1. **Read-only where possible** - Most subagents only need to analyze code
2. **Write-only for generated artifacts** - Linting, testing, documentation subagents can write only their specific output files
3. **Delegation required** - System operations (bash, git, tofu, npm, etc.) must be delegated to the default agent
4. **MCP restriction** - Each subagent only gets MCP servers relevant to their domain
5. **Skill isolation** - Subagents only load skills matching their specialization via permission filters

---

*This file is part of the OpenCode configuration system. See config.json for agent definitions and project-level .AGENTS.md for project-specific rules.*
