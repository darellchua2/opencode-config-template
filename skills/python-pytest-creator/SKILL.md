---
name: python-pytest-creator
description: Generate comprehensive pytest test files for Python using test-generator-framework
license: Apache-2.0
compatibility: opencode
metadata:
  audience: developers
  workflow: python-testing
---

## What I do

I implement Python pytest test generation by extending `test-generator-framework`:

- **Analyze Python Codebase**: Scan for functions, classes, and modules
- **Detect Python Testing Setup**: Identify pytest version and Poetry availability
- **Generate Python-Specific Scenarios**: Create comprehensive test scenarios for decorators, context managers, async functions
- **Delegate to Framework**: Use `test-generator-framework` for core workflow
- **Ensure Executability**: Verify tests run with `poetry run pytest` or `pytest`

## When to use me

Use when:
- Creating comprehensive pytest test files for a Python application
- Ensuring edge cases and error conditions are covered
- Integrating tests with Poetry environments
- Preferring systematic test generation with user confirmation
- Ensuring tests run correctly with project's pytest version

**Framework**: Extends `test-generator-framework` for core workflow, adding Python-specific functionality.

## Prerequisites

- Python project with Poetry (`pyproject.toml`) or pip (`requirements.txt`)
- Pytest installed and configured
- Python source code to test
- File permissions to create test files

**Note**: Poetry is optional. If Poetry and `pyproject.toml` exist, use `poetry run pytest`. Otherwise, use `pytest` directly.

## Steps

### Step 1: Analyze Python Codebase

Use glob patterns to find Python files and identify testable items:

```bash
# Find Python files (exclude existing tests)
**/*.py
exclude: **/test_*.py, **/*_test.py, **/tests/**/*.py
```

For each file, identify:
- Functions: `def function_name(parameters):`
- Classes: `class ClassName:`
- Methods: `def method_name(self, parameters):`
- Async functions: `async def async_function():`
- Decorators: `@decorator_name`
- Context managers: `with context_manager():`
- Import statements

### Step 2: Detect Python Testing Setup

```bash
# Check for Poetry
poetry --version 2>/dev/null

# Determine pytest command
if command -v poetry && [ -f pyproject.toml ]; then
    PYTEST_CMD="poetry run pytest"
else
    PYTEST_CMD="pytest"
fi
```

### Step 3: Generate Test Scenarios

#### Function Scenarios
- **Happy Path**: Normal inputs with expected outputs
- **Edge Cases**: Empty strings, empty lists, `None`, `0`, `-1`
- **Error Cases**: Invalid types, out of range values
- **Python Features**: Decorators, type hints, default arguments, *args/**kwargs

#### Class Scenarios
- **Initialization**: `__init__` with valid/invalid parameters
- **Method Behavior**: Public/private method testing
- **Special Methods**: `__str__`, `__repr__`, `__eq__`, `__hash__`, `__len__`
- **Class Methods**: `@classmethod`, `@staticmethod`
- **Properties**: `@property` getter/setter/deleter
- **Context Managers**: `__enter__` and `__exit__`

#### Async Function Scenarios
- **Awaitable Results**: Normal async execution
- **Concurrency**: Multiple async calls with `asyncio.gather()`
- **Error Handling**: Async exceptions with `pytest.raises()`
- **Timeout**: Tests that should timeout

### Step 4: Create Test Files

**Note**: Core workflow provided by `test-generator-framework`. This skill adds Python-specific patterns.

```python
"""
Test suite for <module_name>.py
Generated by python-pytest-creator skill
"""

import pytest
from <module_path> import <function_name>, <ClassName>

@pytest.fixture
def sample_instance():
    """Create a sample instance for testing"""
    return ClassName(param1, param2)

def test_function_name_happy_path(sample_instance):
    """Test that function_name works with valid inputs"""
    result = function_name(valid_input)
    assert result == expected_output

def test_function_name_edge_case_empty():
    """Test that function_name handles empty input"""
    result = function_name("")
    assert result is None

def test_function_name_error_invalid_type():
    """Test that function_name raises ValueError for invalid type"""
    with pytest.raises(ValueError):
        function_name(invalid_input)

@pytest.mark.parametrize("input,expected", [
    (1, "one"),
    (2, "two"),
])
def test_function_name_parametrized(input, expected):
    """Test function_name with multiple inputs"""
    result = function_name(input)
    assert result == expected

class TestClassName:
    """Test suite for ClassName"""

    def test_initialization(self):
        """Test that ClassName initializes correctly"""
        instance = ClassName(param1, param2)
        assert instance.attribute == expected_value

    def test_method_behavior(self, sample_instance):
        """Test that ClassName.method_name works correctly"""
        result = sample_instance.method_name(param)
        assert result == expected_result

@pytest.mark.asyncio
async def test_async_function_happy_path():
    """Test successful async execution"""
    result = await async_function(valid_input)
    assert result["status"] == "success"
```

**Pytest features**:
- **Fixtures**: `@pytest.fixture` for common setup
- **Parametrization**: `@pytest.mark.parametrize` for multiple test cases
- **Marks**: `@pytest.mark.unit`, `@pytest.mark.integration`, `@pytest.mark.slow`
- **Async**: `@pytest.mark.asyncio` for async functions

### Step 5: Verify Executability

Refer to `test-generator-framework` for core verification.

```bash
# If Poetry:
poetry run pytest tests/test_<module_name>.py -v
poetry run pytest --cov=<module_name> tests/

# Otherwise:
pytest tests/test_<module_name>.py -v
pytest --cov=<module_name> tests/
```

### Step 6: Display Summary

```
âœ… Python test files created successfully!

**Test Files Created:**
- tests/test_<module_name>.py (<number> tests)

**Total Tests Generated:** <number>
**Test Framework:** Pytest

**Python-Specific Categories:**
- Decorator tests: <number>
- Context manager tests: <number>
- Special method tests: <number>
- Async function tests: <number>

**To run tests:**
poetry run pytest -v  # or: pytest -v
```

## Python-Specific Patterns

### Decorator Testing
- Decorator modifies function behavior correctly
- Decorator chaining applies correctly
- Decorator arguments work
- Class decorators function properly

### Context Manager Testing
- `__enter__` returns context correctly
- `__exit__` cleans up resources
- Exception handling in context works
- Nested context managers work together

### Special Methods
- `__str__`: String representation is correct
- `__repr__`: Developer representation is correct
- `__eq__`: Equality comparison works
- `__hash__`: Hash allows use in sets/dicts
- `__len__`: Length function returns correct value
- `__getitem__`: Item access works
- `__setitem__`: Item assignment works

### Property Testing
- Getter returns correct value
- Setter sets value correctly
- Deleter handles deletion
- Cached properties work correctly

## Best Practices

Refer to `test-generator-framework` for general best practices.

**Python-specific**:
- Use pytest fixtures for common setup
- Use `@pytest.mark.asyncio` for async functions
- Include type hints for better test coverage
- Use `pytest-mock` or `unittest.mock` appropriately
- Parametrize tests with `@pytest.mark.parametrize`
- Mark tests with categories (unit, integration, slow)

## Common Issues

Refer to `test-generator-framework` for general issues.

**Python-specific**:

### Poetry Not Installed
**Issue**: `poetry run pytest` command not found

**Solution**: Use `pytest` directly
```bash
pytest tests/
```

### pytest-asyncio Not Installed
**Issue**: Async tests fail or don't run

**Solution**: Install pytest-asyncio
```bash
poetry add --group dev pytest-asyncio
# or
pip install pytest-asyncio
```

### Module Not Found
**Issue**: Import errors for modules to test

**Solution**: Add source to PYTHONPATH
```bash
export PYTHONPATH="${PYTHONPATH}:$(pwd)"
```

## Commands

```bash
# Poetry commands
poetry run pytest -v
poetry run pytest --cov=<module> tests/
poetry install --group dev pytest-asyncio

# Direct pytest commands
pytest -v
pytest tests/test_module.py -v
pytest --cov=<module> tests/
pytest -k "test_name"

# Python commands
python -m pytest
export PYTHONPATH="${PYTHONPATH}:$(pwd)"
```

## References

- **test-generator-framework**: Core test generation framework
- **Pytest Documentation**: https://docs.pytest.org/
- **pytest-asyncio**: https://pytest-asyncio.readthedocs.io/
- **coverage-readme-workflow**: Update README with coverage badges
- **python-ruff-linter**: Python code quality before testing
