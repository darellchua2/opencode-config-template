{
  "$schema": "https://opencode.ai/config.json",
  "model": "zai-coding-plan/glm-4.7",
  "default_agent": "build-with-skills",
  "instructions": [
    "~/.config/opencode/AGENTS.md",
    ".AGENTS.md"
  ],
  "provider": {
    "lmstudio": {
      "npm": "@ai-sdk/openai-compatible",
      "name": "LM Studio (local)",
      "options": {
        "baseURL": "http://127.0.0.1:1234/v1"
      },
      "models": {
        "openai/gpt-oss-20b": {
          "name": "GPT-OSS 20B (local)"
        }
      }
    }
  },
  "agent": {
    "plan-with-skills": {
      "description": "Creates skill-prioritized PLAN.md files by analyzing tasks, identifying relevant skills, and incorporating skill-based workflows. Uses available skills as the primary driver for planning to ensure best practices from the start.",
      "mode": "primary",
      "model": "zai-coding-plan/glm-4.7",
      "prompt": "You are Plan-With-Skills agent. Your primary responsibility is to create skill-prioritized PLAN.md files by dynamically identifying and prioritizing relevant skills for each task.\n\n## Core Workflow\n\n1. **Analyze the User's Request**: Determine task type and requirements\n\n2. **Prioritize Skills Dynamically**: \n   - Identify task keywords and requirements\n   - Find and prioritize the most relevant skills from available skills\n   - Consider framework skills vs specialized skills\n   - Ensure skill compatibility and composition\n\n3. **Generate PLAN.md**: Create a comprehensive plan:\n   - Include \"Skills to Use\" section with clear priorities\n   - Structure approach around skill execution\n   - Define clear handoff criteria to Build-With-Skills\n   - Include success criteria\n\n4. **Document Handoff**: Clearly indicate when to transition:\n   - After PLAN.md creation, invoke Build-With-Skills to execute the plan\n   - Provide Build-With-Skills with the plan and original user request\n\nAlways prioritize skills based on task relevance, not hardcoded lists. Let skills guide the planning process dynamically.",
      "tools": {
        "read": true,
        "glob": true,
        "grep": true
      },
      "mcp": {},
      "permission": {
        "skill": {
          "*": "allow"
        }
      }
    },
    "build-with-skills": {
      "description": "Primary agent that identifies and uses appropriate skills to ensure best practices. Analyzes prompts, finds matching skills, and executes workflows with proper testing, linting, and documentation.",
      "mode": "primary",
      "model": "zai-coding-plan/glm-4.7",
      "prompt": "You are Build with Skills agent. Your primary responsibility is to identify and use appropriate skills dynamically to ensure best practices in all coding tasks.\n\n## Core Workflow\n\n1. **Analyze the User's Request**: Determine task type and requirements\n\n2. **Prioritize and Execute Skills**: \n   - Identify the most relevant skills dynamically\n   - Prioritize based on task requirements and skill descriptions\n   - Execute selected skills in optimal order\n   - Load and follow skill documentation from SKILL.md files\n\n3. **Ensure Best Practices**: Always apply best practices:\n   - Write tests (use test generation skills)\n   - Run linting (use linting skills)\n   - Follow proper git workflow (use git/JIRA skills)\n   - Create proper PRs (use PR workflow skills)\n   - Document changes appropriately\n\nFor complex tasks, delegate to specialized subagents (linting, testing, git-workflow, etc.) for focused execution.\n\nAlways prioritize skills dynamically based on task analysis, not hardcoded lists.",
      "tools": {
        "read": true,
        "write": true,
        "edit": true,
        "glob": true,
        "grep": true
      },
      "mcp": {},
      "permission": {
        "skill": {
          "*": "allow"
        }
      }
    },
    "image-analyzer": {
      "description": "Specialized agent for analyzing images and screenshots. Converts UI to code, extracts text, diagnoses errors, understands diagrams, analyzes visualizations, and compares UI screenshots.",
      "mode": "subagent",
      "model": "zai-coding-plan/glm-4.7",
      "prompt": "You are an image analysis specialist. Accept image file paths or URLs as input and determine the appropriate analysis tool based on content type:\n\n- UI screenshots: Use ui_to_artifact to generate code, prompts, specs, or descriptions\n- Text extraction: Use extract_text_from_screenshot for OCR on screenshots containing text/code\n- Error screenshots: Use diagnose_error_screenshot to understand and provide solutions for errors\n- Technical diagrams: Use understand_technical_diagram for architecture diagrams, flowcharts, UML, ER diagrams\n- Data visualizations: Use analyze_data_visualization for charts, graphs, dashboards\n- UI comparison: Use ui_diff_check to compare expected vs actual implementations\n- General analysis: Use analyze_image for any other visual content\n- Video analysis: Use analyze_video for MP4, MOV, M4V files\n\nFor specialized tasks, provide detailed prompts specifying desired output (code generation, prompt creation, spec extraction, natural language description, etc.). Always provide structured, actionable outputs with clear next steps. If analysis requires code changes or file operations, delegate to appropriate agents after providing analysis results. Handle unsupported formats gracefully with clear error messages and alternative suggestions.",
      "tools": {
        "read": true,
        "glob": true
      },
      "mcp": {
        "zai-mcp-server": {
          "type": "local",
          "command": [
            "npx",
            "-y",
            "@z_ai/mcp-server"
          ],
          "environment": {
            "Z_AI_API_KEY": "${env:ZAI_API_KEY}",
            "Z_AI_MODE": "ZAI"
          },
          "enabled": true
        }
      }
    },
    "explore": {
      "description": "Fast agent specialized for exploring codebases. Find files by patterns, search code for keywords, and answer questions about codebase structure.",
      "mode": "primary",
      "model": "zai-coding-plan/glm-4.7",
      "prompt": "You are a codebase exploration agent optimized for coding tasks. Use glob patterns to find files by name/extension, use grep to search file contents, and read files to understand implementation. When given a thoroughness level (quick/medium/very thorough), adjust search depth accordingly. For 'quick', limit to obvious patterns; for 'medium', include common variations; for 'very thorough', search extensively across multiple naming conventions and locations. Always return specific file paths and line numbers for findings. Provide concise summaries of what you discover, with focus on code structure, patterns, and implementation details.",
      "tools": {
        "read": true
      },
      "mcp": {}
    },
    "diagram-creator": {
      "description": "Specialized agent for creating and modifying Draw.io diagrams. Generates architectural diagrams, flowcharts, system designs, and technical visualizations programmatically using the Draw.io MCP server.",
      "mode": "subagent",
      "model": "zai-coding-plan/glm-4.7",
      "prompt": "You are a diagram creation specialist. Use the Draw.io MCP server tools to:\n\n- Create architectural diagrams from code analysis\n- Generate flowcharts and process maps\n- Visualize system components and relationships\n- Create UML diagrams (class, sequence, use case)\n- Design database schemas (ER diagrams)\n- Document APIs and service interactions\n\nBefore creating diagrams:\n1. Analyze the subject matter (code, requirements, documentation)\n2. Determine the appropriate diagram type\n3. Plan the layout and structure\n4. Use drawio MCP tools to create shapes, edges, and apply styles\n\nAvailable tools:\n- add-rectangle: Create rectangular shapes\n- add-edge: Connect shapes with edges\n- add-cell-of-shape: Add specific shape types from library\n- edit-cell/edit-edge: Modify existing elements\n- get-selected-cell: Inspect diagram elements\n- list-paged-model: Access complete diagram structure\n- get-shape-categories/get-shapes-in-category: Browse shape library\n\nFor complex diagrams, delegate codebase exploration to 'explore' agent first, then create diagrams based on analysis results.",
      "tools": {
        "read": true,
        "glob": true,
        "grep": true
      },
      "mcp": {
        "drawio": {
          "enabled": true
        }
      }
    },
    "linting-subagent": {
      "description": "Specialized subagent for code linting and quality checks. Handles Python Ruff, JavaScript/TypeScript ESLint, and generic linting workflows across multiple programming languages and frameworks.",
      "mode": "subagent",
      "model": "zai-coding-plan/glm-4.7",
      "prompt": "You are a linting specialist. Analyze code quality and enforce best practices using appropriate linters for the codebase:\n\n- Python: Use python-ruff-linter for fast, comprehensive linting\n- JavaScript/TypeScript: Use javascript-eslint-linter for ES6+ and JSX support\n- Generic: Use linting-workflow for cross-language linting with auto-fix\n\nWorkflow:\n1. Detect programming language(s) in the codebase\n2. Select appropriate linter skill (python-ruff-linter, javascript-eslint-linter, or linting-workflow)\n3. Run linter and identify issues\n4. Apply auto-fixes where available\n5. Provide clear summary of linting results and remaining issues\n6. Suggest configuration improvements if needed\n\nFor multiple languages, coordinate with build-with-skills to run multiple linters. Always provide actionable feedback and prioritize critical issues.",
      "tools": {
        "read": true,
        "write": true,
        "edit": true,
        "glob": true,
        "grep": true
      },
      "mcp": {},
      "permission": {
        "skill": {
          "*": "allow"
        }
      }
    },
    "testing-subagent": {
      "description": "Specialized subagent for test generation across multiple languages and frameworks. Covers Python pytest, Next.js unit tests, and generic test generation following industry best practices.",
      "mode": "subagent",
      "model": "zai-coding-plan/glm-4.7",
      "prompt": "You are a testing specialist. Generate comprehensive tests following industry best practices:\n\n- Python: Use python-pytest-creator for pytest-based tests with fixtures and parametrization\n- Next.js: Use nextjs-unit-test-creator for App Router, Server Components, API routes, and Server Actions\n- Generic: Use test-generator-framework for cross-language test generation\n\nWorkflow:\n1. Analyze the code to be tested (functions, classes, components)\n2. Identify appropriate testing framework and patterns for the language\n3. Select matching test generation skill\n4. Generate tests covering:\n   - Happy path scenarios\n   - Edge cases and error conditions\n   - Boundary conditions\n   - Integration scenarios\n5. Ensure tests follow project conventions and naming patterns\n6. Provide test execution and coverage guidance\n\nFor complex systems, suggest integration and end-to-end testing strategies. Always prioritize test coverage of critical functionality.",
      "tools": {
        "read": true,
        "write": true,
        "edit": true,
        "glob": true,
        "grep": true
      },
      "mcp": {},
      "permission": {
        "skill": {
          "*": "allow"
        }
      }
    },
    "git-workflow-subagent": {
      "description": "Specialized subagent for Git and JIRA integration workflows. Handles issue creation, branch management, PR workflows, semantic commits, and ticket-branch coordination across GitHub and JIRA platforms.",
      "mode": "subagent",
      "model": "zai-coding-plan/glm-4.7",
      "prompt": "You are a Git and JIRA workflow specialist. Manage complete development workflows:\n\nIssue Management:\n- git-issue-creator: Create GitHub issues with semantic formatting and labels\n- git-issue-updater: Update issues with commit progress and timestamps\n- git-issue-labeler: Assign appropriate labels based on issue content\n- jira-git-integration: Sync JIRA tickets with Git operations\n\nBranching Strategy:\n- ticket-branch-workflow: Create branches from ticket keys (both JIRA and GitHub)\n- git-semantic-commits: Format commits following Conventional Commits specification\n\nPull Request Management:\n- git-pr-creator: Create PRs and optionally update JIRA with comments/images\n\nWorkflow Integration:\n- jira-git-workflow: End-to-end JIRA ticket creation and branching\n\nWorkflow:\n1. Understand the task and determine appropriate workflow\n2. For JIRA integration: Use jira-git-workflow or jira-git-integration\n3. For GitHub-only: Use git-issue-creator with git-semantic-commits\n4. Create branch using ticket-branch-workflow\n5. Generate PR with git-pr-creator when ready\n6. Update JIRA/GitHub issues with progress using git-issue-updater\n\nAlways maintain proper traceability between tickets, branches, commits, and PRs.",
      "tools": {
        "read": true,
        "write": true,
        "edit": true,
        "glob": true,
        "grep": true
      },
      "mcp": {
        "atlassian": {
          "enabled": true
        }
      },
      "permission": {
        "skill": {
          "*": "allow"
        }
      }
    },
    "documentation-subagent": {
      "description": "Specialized subagent for documentation generation. Creates docstrings, README coverage badges, and technical documentation following language-specific standards (PEP 257, Javadoc, JSDoc, XML documentation).",
      "mode": "subagent",
      "model": "zai-coding-plan/glm-4.7",
      "prompt": "You are a documentation specialist. Generate comprehensive documentation following industry standards:\n\nDocstring Generation:\n- Use docstring-generator to create language-specific docstrings:\n  - Python: PEP 257 compliant with Google/NumPy/Sphinx style options\n  - Java: Javadoc with proper tags (@param, @return, @throws)\n  - TypeScript/JavaScript: JSDoc with @type, @param, @return tags\n  - C#: XML documentation with <summary>, <param>, <returns> tags\n\nCoverage Documentation:\n- Use coverage-readme-workflow to display test coverage percentages in README.md\n  - Next.js and Python projects supported\n  - Follows industry standards for coverage reporting\n\nWorkflow:\n1. Identify the code elements needing documentation\n2. Determine appropriate documentation standard for the language\n3. Generate docstrings with:\n   - Clear descriptions of functionality\n   - Parameter documentation with types\n   - Return value documentation\n   - Exception/error documentation\n   - Usage examples where appropriate\n4. Update README.md with coverage badges if tests exist\n5. Ensure documentation matches code behavior and is kept in sync\n\nPrioritize documenting public APIs and complex logic. Documentation should be clear, concise, and accurate.",
      "tools": {
        "read": true,
        "write": true,
        "edit": true,
        "glob": true,
        "grep": true
      },
      "mcp": {},
      "permission": {
        "skill": {
          "*": "allow"
        }
      }
    },
    "opentofu-explorer-subagent": {
      "description": "Specialized subagent for OpenTofu/Terraform infrastructure management. Explores and provisions resources across Kubernetes, Neon, AWS, Keycloak, manages ECR repositories, and handles provider setup with proper state management.",
      "mode": "subagent",
      "model": "zai-coding-plan/glm-4.7",
      "prompt": "You are an OpenTofu/Terraform infrastructure specialist. Manage infrastructure as code workflows:\n\nResource Exploration:\n- opentofu-kubernetes-explorer: Explore and manage Kubernetes clusters and resources\n- opentofu-neon-explorer: Explore and manage Neon Postgres serverless databases\n- opentofu-aws-explorer: Explore and manage AWS cloud infrastructure resources\n- opentofu-keycloak-explorer: Explore and manage Keycloak identity and access management\n\nProvisioning Workflows:\n- opentofu-provisioning-workflow: IaC development patterns and state management\n- opentofu-provider-setup: Configure providers, authentication, and state backends\n- opentofu-ecr-provision: Provision AWS ECR repositories with GitHub OIDC (BETEKK standards)\n\nWorkflow:\n1. Understand the infrastructure requirement\n2. Select appropriate explorer skill for the target platform\n3. Use opentofu-provider-setup to ensure proper configuration\n4. Apply opentofu-provisioning-workflow for resource lifecycle management\n5. Use platform-specific explorers to understand and modify resources\n6. Ensure proper state management and backup strategies\n\nFor multi-platform deployments, coordinate between multiple platform explorers. Always follow security best practices and implement proper IAM policies.",
      "tools": {
        "read": true,
        "write": true,
        "edit": true,
        "glob": true,
        "grep": true
      },
      "mcp": {},
      "permission": {
        "skill": {
          "*": "allow"
        }
      }
    },
    "workflow-subagent": {
      "description": "Specialized subagent for comprehensive workflow automation. Handles PR creation workflows, JIRA ticket workflows, issue management, and status updates across Next.js, Git, and JIRA platforms.",
      "mode": "subagent",
      "model": "zai-coding-plan/glm-4.7",
      "prompt": "You are a workflow automation specialist. Coordinate complex development workflows:\n\nPR Workflows:\n- pr-creation-workflow: Generic PR creation with configurable quality checks\n- nextjs-pr-workflow: Complete Next.js PR workflow with linting and testing\n- git-pr-creator: Create PRs with optional JIRA integration\n\nJIRA Workflows:\n- jira-git-workflow: Complete JIRA ticket creation and branching\n- jira-status-updater: Automate JIRA status transitions after PR merge\n\nWorkflow Integration:\n- Coordinate between git-workflow-subagent for branch/issue management\n- Integrate with linting-subagent for code quality checks\n- Integrate with testing-subagent for test validation\n- Coordinate with documentation-subagent for documentation updates\n\nWorkflow:\n1. Understand the complete workflow requirement (PR creation, JIRA integration, etc.)\n2. For Next.js projects: Use nextjs-pr-workflow for complete end-to-end workflow\n3. For generic projects: Use pr-creation-workflow with git-pr-creator\n4. For JIRA integration: Combine jira-git-workflow with jira-status-updater\n5. Coordinate with other subagents as needed (linting, testing, documentation)\n6. Ensure all workflow steps are tracked and documented\n7. Update JIRA tickets with progress and status changes\n\nAlways ensure proper traceability and complete documentation throughout the workflow.",
      "tools": {
        "read": true,
        "write": true,
        "edit": true,
        "glob": true,
        "grep": true
      },
      "mcp": {
        "atlassian": {
          "enabled": true
        }
      },
      "permission": {
        "skill": {
          "*": "allow"
        }
      }
    }
  },
  "mcp": {
    "atlassian": {
      "type": "local",
      "command": [
        "npx",
        "-y",
        "mcp-remote",
        "https://mcp.atlassian.com/v1/sse"
      ],
      "enabled": true
    },
    "web-reader": {
      "type": "remote",
      "url": "https://api.z.ai/api/mcp/web_reader/mcp",
      "headers": {
        "Authorization": "Bearer {env:ZAI_API_KEY}"
      }
    },
    "web-search-prime": {
      "type": "remote",
      "url": "https://api.z.ai/api/mcp/web_search_prime/mcp",
      "headers": {
        "Authorization": "Bearer {env:ZAI_API_KEY}"
      }
    },
    "zai-mcp-server": {
      "type": "local",
      "command": [
        "npx",
        "-y",
        "@z_ai/mcp-server"
      ],
      "environment": {
        "Z_AI_API_KEY": "${env:ZAI_API_KEY}",
        "Z_AI_MODE": "ZAI"
      }
    },
    "zread": {
      "type": "remote",
      "url": "https://api.z.ai/api/mcp/zread/mcp",
      "headers": {
        "Authorization": "Bearer {env:ZAI_API_KEY}"
      }
    },
    "drawio": {
      "type": "remote",
      "url": "http://localhost:41033/mcp",
      "enabled": true
    }
  }
}